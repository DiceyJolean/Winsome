race condition mentre il reward calculator è in esecuzione

aggiunta di un nuovo utente
aggiunta di un nuovo post
aggiunta di un nuovo voto
aggiunta di un nuovo commento
eliminazione di un post
vista di un post
vista del wallet
vista del wallet in bitcoin

oppure se lavoro su una copia ci sono i seguenti problemi:
(un utente non può cancellarsi)
un nuovo utente può iscriversi e non avrebbe il portafoglio aggiornato (in realtà non causa problemi)
come aggiorno il portafoglio? basterebbe chiamare un metodo di user, ma user è una copia...
come faccio lo switch di voti e commenti da nuovi a vecchi? basterebbe chiamare un metodo di post, ma post è una copia...
se nel frattempo viene cancellato un post che faccio? lo calcolo? alla fine ha senso, dato che calcolo le ricompense sull'istanza di un certo istante

altra race condition:

i metodi per aggiornare post come switchtoold e per aggiornare gli utenti come updatereward creare race condition
fra server e reward, metto synch quali metodi? e la concurrent hashmap per i post allora, che senso ha?

poi!!!

anche il thread che fa la copia del database crea race condition, sincronizzo il database ma... lo sincronizzo tutto?
lo so che fa presto, ma una volta che i metodi sono sincronizzati poi sono più lenti sempre e a prescindere
probabilmente l'idea migliore è quella di mettere delle readwrite lock nella classe database

vantaggi readwrite lock:

granularità molto fine
posso rendere concorrenti solo i blocchi interessati dalle race condition, senza dover sincronizzare tutto il metodo
devo sincronizzare tutti quei punti in cui passa il reward: 
lettura per il calcolo dei commenti e voti su ogni post, ma se lavora su una copia è meglio, copia solo della struttura dei post, la stessa che si usa per il backup, posso ottimizzare?
poi scrittura per l'aggiornamento di post e user, basta ottenere la write lock all'interno dei metodi
per il backup cosa devo sincronizzare? la struttura degli utenti, la stessa che poi serve al reward...


per il backup devo sincronizzare tutto! perché ogni modifica di qualsiasi campo di una qualsiasi struttura è una race condition!

SI TORNA ALL'IDEA DI FARE UNA COPIA DELLA STRUTTURA DEGLI UTENTI PER IL SALVATAGGIO DELLO STATO
inutile bloccare in scrittura per ogni operazione
il risparmio non è tanto la copia in sè quanto non bloccare in scrittura (!!!) ogni volta
